<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <ul>
        <li>aaa</li>
        <li>bbb</li>
        <li>ccc</li>
        <li>ddd</li>
    </ul>    

    <script>
        var aLi = document.getElementsByTagName('li');

        //一 let: 
        // 1、let没有变量提升

            console.log(b);//报错
            let b =5; //变量b不能提升


        //2、 let 不能重复声明

            let a = 5;//定义a赋值6
            let a = 6;//不能重复声明
            console.log(a);//报错 


        // 3、暂时性死区  (let在当前作用域中不允许同名的变量进来)
            let b = 5; //定义b赋值5
            bb = function(){
                console.log(b);//报错 外面的同名全局变量进不来
                let b = 10;//定义b赋值10 
            }
            bb();

        //闭包 外部函数中有内部函数, 内部函数引用外部函数的变量,
            //这样变量不释放,一直保存，这样形成闭包。
            //缺点： 容易导致内存泄漏
            

            for(let i =0;i<aLi.length;i++){
                aLi[i].onclick=function(){
                    console.log(i)//i=4
                }

            for(var i = 0;i<aLi.length;i++){
                (function(idx){
                    aLi[i].onclick = function(){
                        console.log(idx);
                    }
                })(i)//函数立即调用
            }


        //4、 块级作用域
            for(let i = 0;i<5;i++){
                console.log(i)
            }
            console.log(i);//报错 因为let有块级作用域

            for(let i =0;i<aLi.length;i++){
                aLi[i].onclick=function(){
                    console.log(i)//i= 1、2、3、4
                }
            }//{外部作用域{内部作用域}} 可以如下理解

            for(var i = 0;i<aLi.length;i++){
                (function(idx){
                    aLi[i].onclick = function(){
                        console.log(idx);
                    }
                })(i)//{}是一个作用域  {外部作用域变量i{内部作用域引用外部作用于变量i i不释放}}
            }


        
            

        


    </script>
</body>
</html>